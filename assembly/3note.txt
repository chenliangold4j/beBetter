1.第一个程序
    main PROC
        mov eax, 5               ;将数字 5 送入 eax 寄存器
        add eax, 6               ;eax 寄存器加 6
        INVOKE ExitProcess, 0    ;程序结束
    main ENDP

    现在按照一次一行代码的方法来仔细查看这段程序：
    第 1 行开始 main 程序（主程序），即程序的入口；
    第 2 行将数字 5 送入 eax 寄存器；
    第 3 行把 6 加到 EAX 的值上，得到新值 11；
    第 5 行调用 Windows 服务（也被称为函数）ExitProcess 停止程序，并将控制权交还给操作系统；
    第 6 行是主程序结束的标记。

2.添加变量
    现在让这个程序变得有趣些，将加法运算的结果保存在变量 sum 中。要实现这一点，需要增加一些标记，或声明，用来标识程序的代码和数据区：
    .data                          ;此为数据区
    sum DWORD 0                    ;定义名为sum的变量
    .code                          ;此为代码区
    main PROC
        mov eax,5                  ;将数字5送入而eax寄存器
        add eax,6                  ;eax寄存器加6
        mox sum,eax
        INVOKE ExitProcess,0       ;结束程序
    main ENDP
    变量 sum 在第 2 行进行了声明，其大小为 32 位，使用了关键字 DWORD。汇编语言中有很多这样的大小关键字，其作用或多或少与数据类型一样。

    但是与程序员可能熟悉的类型相比它们没有那么具体，比如 int、double、float 等等。这些关键字只限制大小，并不检查变量中存放的内容。记住，程序员拥有完全控制权。

    顺便说一下，那些被 .code 和 .data 伪指令标记的代码和数据区，被称为段。即，程序有代码段和数据段。

3.常量
    http://c.biancheng.net/view/3464.html
    “E”后跟一个整数来表示以“10”为底数的幂数
4.伪指令
    伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。

    默认情况下，伪指令不区分大小写。例如，.data，.DATA 和 .Data 是相同的。

    下面的例子有助于说明伪指令和指令的区别。DWORD 伪指令告诉汇编器在程序中为一个双字变量保留空间。另一方面，MOV 指令在运行时执行，将 myVar 的内容复制到 EAX 寄存器中：
    myVar DWORD 26
    mov eax,myVar
    尽管 Intel 处理器所有的汇编器使用相同的指令集，但是通常它们有着不同的伪指令。比如，Microsoft 汇编器的 REPT 伪指令对其他一些汇编器就是无法识别的。
    定义段
    汇编器伪指令的一个重要功能是定义程序区段，也称为段 (segment)。程序中的段具有不同的作用。如下面的例子，一个段可以用于定义变量，并用 .DATA 伪指令进行标识：
    .data

    .CODE 伪指令标识的程序区段包含了可执行的指令：
    .code

    .STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小：
    .stack 100h
5.