1.AND 指令
    AND 指令在两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目标操作数中：
    AND destination,source

    如，设 AL 初始化为二进制数 1010 1110，将其与 1111 0110 进行 AND 操作后，AL 等于 1010 0110：
    mov al,10101110b
    and al, 11110110b    ;AL 中的结果 = 1010 0110

    标志位
        AND 指令总是清除溢出和进位标志位，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。
        比如，下面指令的结果存放在 EAX 寄存器，假设其值为 0。在这种情况下，零标志位就会置 1：
        and eax,1Fh

2.OR
    OR 指令在两个操作数的对应位之间进行（按位）逻辑或（OR）操作，并将结果存放在目标操作数中：
    OR destination, source

    OR 指令总是清除进位和溢出标志位，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。比如，可以将一个数与它自身（或 0）进行 OR 运算，来获取该数值的某些信息：
    or al,al

    下表给出了零标志位和符号标志位对 AL 内容的说明：

    零标志位	符号标志位	AL 中的值
    清0	         清0	     大于0
    置1	         清0	     等于0
    清0        	 置1	     小于0

3.XOR 
    指令在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中：
    XOR destination, source

    标志位
    XOR 指令总是清除溢岀和进位标志位，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。
    检查奇偶标志
    奇偶检查是在一个二进制数上实现的功能，计算该数中 1 的个数；如果计算结果为偶数，则说该数是偶校验；如果结果为奇数，则该数为奇校验。

    x86 处理器中，当按位操作或算术操作的目标操作数最低字节为偶校验时，奇偶标志位置 1。反之，如果操作数为奇校验，则奇偶标志位清 0。一个既能检查数的奇偶性，又不会修改其数值的有效方法是，将该数与 0 进行异或运算：
    mov al,10110101b              ;5 个 1,奇校验
    xor al, 0                               ;奇偶标志位清 0 （奇）
    mov al, 11001100b             ;4 个 1，偶校验
    xor al, 0                               ;奇偶标志位置 1（偶）

    Visual Studio 用 PE=1 表示偶校验，PE=0 表示奇校验。

4.NOT 指令
    例如，F0h 的反码是 0Fh：
    mov al,11110000b
    not al                          ;AL = 00001111b

5.TEST 
    指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。
    TEST 指令与《AND指令》一节中介绍的 AND 指令唯一不同的地方是，TEST 指令不修改目标操作数。TEST 指令允许的操作数组合与 AND 指令相同。在发现操作数中单个位是否置位时，TEST 指令非常有用。
    示例：多位测试
    TEST 指令同时能够检查几个位。假设想要知道 AL 寄存器的位 0 和位 3 是否置 1，可以使用如下指令：
    test al, 00001001b ;测试位 0 和位 3

    （本例中的 0000 1001 称为位掩码。）从下面的数据集例子中，可以推断只有当所有测试位都清 0 时，零标志位才置 1：
    0  0  1  0  0  1  0  1    <- 输入值
    0  0  0  0  1  0  0  1    <- 测试值
    0  0  0  0  0  0  0  1    <- 结果：ZF=0

    0  0  1  0  0  1  0  0    <- 输入值
    0  0  0  0  1  0  0  1    <- 测试值
    0  0  0  0  0  0  0  0    <- 结果：ZF=1


6.CMP（比较）指令
    CMP（比较）指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数：
    CMP destination,source

    当实际的减法发生时，CMP 指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位

    下面用三段代码来说明标志位是如何受到 CMP 影响的。设 AX=5，并与 10 进行比较，则进位标志位将置 1，原因是（5-10）需要借位：
    mov ax, 5
    cmp ax,10     ; ZF = 0 and CF = 1

    1000 与 1000 比较会将零标志位置 1，因为目标操作数减去源操作数等于 0：
    mov ax,1000
    mov cx,1000
    cmp cx, ax        ;ZF = 1 and CF = 0

    105 与 0 进行比较会清除零和进位标志位，因为（105-0）的结果是一个非零的正整数。
    mov si,105
    cmp si, 0        ; ZF = 0 and CF = 0


7.修改标志位
    怎样能方便地置位和清除零标志位、符号标志位、进位标志位和溢出标志位？有几种方法，其中的一些需要修改目标操作数。要将零标志位置 1，就把操作数与 0 进行 TEST 或 AND 操作；
    要将零标志位清零，就把操作数与 1 进行 OR 操作：
    test al, 0           ;零标志位置 1
    and al, 0           ;零标志位置 1
    or al, 1              ;零标志位清零

    TEST 指令不修改目的操作数，而 AND 指令则会修改目的操作数。若要符号标志位置 1，将操作数的最高位和 1 进行 OR 操作；若要清除符号标志位，则将操作数最高位和 0 进行 AND 操作：
    or al, 80h         ;符号标志位置 1
    and al, 7Fh       ;符号标志位清零

    若要进位标志位置 1，用 STC 指令；清除进位标志位，用 CLC 指令：
    stc                   ;进位标志位置 1
    clc                   ;进位标志位清零

    若要溢出标志位置 1，就把两个正数相加使之产生负的和数；若要清除溢出标志位，则将操作数和 0 进行 OR 操作：
    mov al,7Fh       ; AL = +127
    inc al                ; AL = 80h (-128), OF=1
    or eax, 0           ; 溢出标志位清零

8.条件跳转
    执行一个条件语句需要两个步骤：
    第一步，用 CMP、AND 或 SUB 操作来修改 CPU 状态标志位；
    第二步，用条件跳转指令来测试标志位，并产生一个到新地址的分支。

    【示例 1】本例中的 CMP 指令把 EAX 的值与 0 进行比较，如果该指令将零标志位置 1，则 JZ（为零跳转）指令就跳转到标号 L1：
        cmp eax, 0
        jz L1                   ;如果 ZF=1 则跳转
        .
        .
        L1：

        【示例 2】本例中的 AND 指令对 DL 寄存器进行按位与操作，并影响零标志位。如果零标志位清零，则 JNZ（非零跳转）指令跳转：
                and dl,10110000b
                jnz L2                         ;如果 ZF=0 则跳转
                .
                .
        L2 :


    Jcond 指令
        当状态标志条件为真时，条件跳转指令就分支到目标标号。否则，当标志位条件为假时，立即执行条件跳转后面的指令。语法如下所示：
        Jcond destination

        cond 是指确定一个或多个标志位状态的标志位条件。下面是基于进位和零标志位的例子：

        JC	进位跳转（进位标志位置 1）
        JNC	无进位跳转（进位标志位清零）
        JZ	为零跳转（零标志位置 1）
        JNZ	非零跳转（零标志位清零）
        CPU 状态标志位最常见的设置方法是通过算术运算、比较和布尔运算指令。条件跳转指令评估标志位状态，利用它们来决定是否发生跳转。    


    用 CMP 指令 假设当 EAX=5 时，跳转到标号 L1。在下面的例子中，如果 EAX=5，CMP 指令就将零标志位置 1；之后，由于零标志位为 1，JE 指令就跳转到 L1：
    cmp eax,5
    je L1                  ;如果相等则跳转

    JE 指令总是按照零标志位的值进行跳转。如果 EAX 不等于 5，CMP 就会清除零标志位，那么，JE 指令将不跳转。

    下例中，由于 AX 小于 6，所以 JL 指令跳转到标号 L1：
    mov ax, 5
    cmp ax, 6
    jl L1                 ;小于则跳转

    下例中，由于 AX 大于4，所以发生跳转：
    mov ax,5
    cmp ax,4
    jg L1              ;大于则跳转    

    其他类似的跳转指令

    1.相等性的比较

    助记符	说明	标志位/寄存器	助记符	说明	标志位/寄存器
    JZ	为零跳转	ZF=1	JNO	无溢出跳转	OF=0
    JNZ	非零跳转	ZF=0	JS	有符号跳转	SF=1
    JC	进位跳转	CF=1	JNS	无符号跳转	SF=0
    JNC	无进位跳转	CF=0	JP	偶校验跳转	PF=1
    JO	溢出跳转	OF=1	JNP	奇校验跳转	PF=0

    助记符	说明
    JE	相等跳转 (leftOp=rightOp)
    JNE	不相等跳转 (leftOp M rightOp)
    JCXZ	CX=0 跳转
    JECXZ	ECX=0 跳转
    JRCXZ	RCX=0 跳转（64 位模式）

    2.无符号数比较

    助记符	说明	助记符	说明
    JA	大于跳转（若 leftOp > rightOp）	JB	小于跳转（若 leftOp < rightOp）
    JNBE	不小于或等于跳转（与 JA 相同）	JNAE	不大于或等于跳转（与 JB 相同）
    JAE	大于或等于跳转（若 leftOp ≥ rightOp）	JBE	小于或等于跳转（若 leftOp ≤ rightOp）
    JNB	不小于跳转（与 JAE 相同）	JNA	不大于跳转（与 JBE 相同）

    3.有符号数比较
    助记符	说明	助记符	说明
    JG	大于跳转（若 leftOp > rightOp）	JL	小于跳转（若 leftOp < rightOp）
    JNLE	不小于或等于跳转（与 JG 相同）	JNGE	不大于或等于跳转（与 JL 相同）
    JGE	大于或等于跳转（若 leftOp ≥ rightOp）	JLE	小于或等于跳转（若 leftOp ≤ rightOp）
    JNL	不小于跳转（与 JGE 相同）	JNG	不大于跳转（与 JLE 相同）

    
9.LOOPZ LOOPE LOOPNZ LOOPNE
    LOOPZ（为零跳转）指令的工作和 LOOP 指令相同，只是有一个附加条件：为零控制转向目的标号，零标志位必须置 1。指令语法如下：
    LOOPZ destination

    LOOPE（相等跳转）指令相当于 LOOPZ 它们有相同的操作码。这两条指令执行如下任务：
    ECX = ECX - 1
    if ECX > 0 and ZF = 1, jump to destination

    否则，不发生跳转，并将控制传递到下一条指令。LOOPZ 和 LOOPE 不影响任何状态标志位。32 位模式下，ECX 是循环计数器；64 位模式下，RCX 是循环计数器。

    LOOPNZ（非零跳转）指令与 LOOPZ 相对应。当 ECX 中无符号数值大于零（减 1 操作之后）且零标志位等于零时，继续循环。指令语法如下：
    LOOPNZ destination

    LOOPNE（不等跳转）指令相当于 LOOPNZ 它们有相同的操作码。这两条指令执行如 下任务：
    ECX = ECX - 1
    if ECX > 0 and ZF = 0, jump to destination

    否则，不发生跳转，并将控制传递到下一条指令。