
1. MODEL
    首先是 .MODEL 伪指令，它告诉汇编程序用的是哪一种存储模式：
    .model flat,stdcall
    32 位程序总是使用平面（flat）存储模式，它与处理器的保护模式相关联。关键字 stdcall 在调用程序时告诉汇编器，怎样管理运行时堆栈。


2.STACK
    然后是 .STACK 伪指令，它告诉汇编器应该为程序运行时堆栈保留多少内存字节：
    .stack 4096
    数值 4096 可能比将要用的字节数多，但是对处理器的内存管理而言，它正好对应了一个内存页的大小。所有的现代程序在调用子程序时都会用到堆栈。
    首先，用来保存传递的参数；其次，用来保存调用函数的代码的地址。

    函数调用结束后，CPU 利用这个地址返回到函数被调用的程序点。此外，运行时堆栈还可以保存局部变量，也就是，在函数内定义的变量。

3.CODE
    .CODE 伪指令标记一个程序代码区的起点，代码区包含了可执行指令。通常，.CODE 的下一行声明程序的入口，按照惯例，一般会是一个名为 main 的过程。
    程序的入口是指程序要执行的第一条指令的位置。用下面两行来传递这个信息：
    .code
    main PROC

4.ENDP
    ENDP 伪指令标记一个过程的结束。如果程序有名为 main 的过程，则 endp 就必须使用同样的名称：
    main ENDP

5.END
    最后，END 伪指令标记一个程序的结束，并要引用程序入口：
    END main
    如果在 END 伪指令后面还有更多代码行，它们都会被汇编程序忽略。程序员可以在这里放各种内容一一程序注释，代码副本等等，都无关紧要。

6.EQU 
    EQU 伪指令把一个符号名称与一个整数表达式或一个任意文本连接起来，它有 3 种格式：
    name EQU expression
    name EQU symbol
    name EQU <text>

7.TEXTEQU 
    TEXTEQU 伪指令，类似于 EQU，创建了文本宏（text macro）。它有 3 种格式：第一种为名称分配的是文本；第二种分配的是已有文本宏的内容；第三种分配的是整数常量表达式：
    name TEXTEQU <text>
    name TEXTEQU textmacro
    name TEXTEQU %constExpr

    例如，变量 prompt1 使用了文本宏 continueMsg：
    continueMsg TEXTEQU <"Do you wish to continue (Y/N)?">
    .data
    prompt1 BYTE continueMsg

8.ALIGN 
    伪指令将一个变量对齐到字节边界、字边界、双字边界或段落边界。
    语法如下：
    ALIGN bound

    Bound 可取值有：1、2、4、8、16。当取值为 1 时，则下一个变量对齐于 1 字节边界（默认情况）。
    当取值为 2 时，则下一个变量对齐于偶数地址。当取值为 4 时，则下一个变量地址为 4 的倍数。
    当取值为 16 时，则下一个变量地址为 16 的倍数，即一个段落的边界。

    下述例子中，bVal 处于任意位置，但其偏移量为 0040 4000。在 wVal 之前插入 ALIGN 2 伪指令，这使得 wVal 对齐于偶地址偏移量：
    bVal BYTE ?           ;00404000h
    ALIGN 2 
    wVal WORD ?           ;00404002h
    bVal2 BYTE ?          ;00404004h
    ALIGN 4 
    dVal DWORD ?          ;00404008h
    dVal2 DWORD ?         ;0040400Ch
    请注意，dVal 的偏移量原本是 0040 4005，但是 ALIGN 4 伪指令使它的偏移量成为 0040 4008。
9.LABEL 
    LABEL伪指令可以插入一个标号，并定义它的大小属性，但是不为这个标号分配存储空间。LABEL 中可以使用所有的标准大小属性，如 BYTE、WORD、DWORD、QWORD 或 TBYTE。

    LABEL 常见的用法是，为数据段中定义的下一个变量提供不同的名称和大小属性。如下例所示，在变量 val32 前定义了一个变量，名称为 val16 属性为 WORD：
    .data
    val16 LABEL WORD
    val32 DWORD 12345678h
    .code
    mov ax,val16          ; AX = 5678h
    mov dx,[val16+2]      ; DX = 1234h
    val16 与 val32 共享同一个内存位置。LABEL 伪指令自身不分配内存。

10.PROC 和 ENDP 伪指令
    定义过程
        由返回语句结束的已命名的语句块。过程用 PROC 和 ENDP 伪指令来定义，并且必须为其分配一个名字（有效标识符）。到目前为止，所有编写的程序都包含了一个名为 main 的过程，例如：
        main PROC
        .
        .
        main ENDP

        当在程序启动过程之外创建一个过程时，就用 RET 指令来结束它。RET 强制 CPU 返回到该过程被调用的位置：
        sample PROC
            .
            .
            ret
        sample ENDP
    过程中的标号
        默认情况下，标号只在其被定义的过程中可见。这个规则常常影响到跳转和循环指令。在下面的例子中，名为 Destination 的标号必须与 JMP 指令位于同一个过程中：
        jmp Destination

        解决这个限制的方法是定义全局标号，即在名字后面加双冒号 (::)。
        Destination::

        就程序设计而言，跳转或循环到当前过程之外不是个好主意。过程用自动方式返回并调整运行时堆栈。如果直接跳出一个过程，则运行时堆栈很容易被损坏。  
    示例：
        三个整数求和
        现在创建一个名为 SumOf 的过程计算三个 32 位整数之和。假设在过程调用之前，整数已经分配给 EAX、EBX 和 ECX。过程用 EAX 返回和数：
        SumOf PROC
            add eax,ebx
            add eax,ecx
            ret
        SumOf ENDP
    过程说明
        要培养的一个好习惯是为程序添加清晰可读的说明。下面是对放在每个过程开头的信息的一些建议：
        对过程实现的所有任务的描述。
        输入参数及其用法的列表，并将其命名为 Receives ( 接收 )。如果输入参数对其数值有特殊要求，也要在这里列岀来。
        对过程返回的所有数值的描述，并将其命名为 Returns ( 返回 )。
        所有特殊要求的列表，这些要求被称为先决条件 (preconditions)，必须在过程被调用之前满足。列表命名为 Requires。例如，对一个画图形线条的过程来说，一个有用的先决条件是该视频显示适配器必须已经处于图形模式。

        上述选择的描述性标号，如 ReceivesReturns 和 Requires，不是绝对的；其他有用的名字也常常被使用。

        有了这些思想，现在对 SumOf 过程添加合适的说明：
        ;-------------------------------------------------------
        ; sumof
        ; 计算 3 个 32 位整数之和并返回和数。
        ; 接收：EAX、EBX和ECX为3个整数，可能是有符号数，也可能是无符号数。
        ; 返回：EAX=和数
        ;------------------------------------------------------
        SumOf PROC
            add eax,ebx
            add eax,ecx
            ret
        SumOf ENDP
        用高级语言，如 C 和 C++，编写的函数，通常用 AL 返回 8 位的值，用 AX 返回 16 位的值，用 EAX 返回 32 位的值。

